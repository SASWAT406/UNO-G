<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO-Style Card Game - Live</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Styles for Appearance and Layout */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1f2937 0%, #4b5563 100%);
            min-height: 100vh;
            color: #1f2937;
        }

        .game-wrapper {
            background-color: #f9fafb;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
            border: 8px solid #cbd5e1;
        }

        /* CARD BASE STYLES */
        .card-base {
            width: 80px;
            height: 110px;
            min-width: 80px; /* Essential for horizontal scrolling */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            color: white;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
            border: 4px solid white;
            line-height: 1;
            padding: 5px;
            user-select: none;
        }
        .card-value {
            font-size: 1.8rem;
            font-weight: 900;
        }
        .card-color-initial {
            font-size: 0.7rem;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .top-card {
            width: 120px;
            height: 160px;
            border-radius: 16px;
            font-size: 36px;
            border: 6px solid #f3f4f6;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }

        .card-clickable {
            cursor: pointer;
            margin-right: 8px; /* Spacing between cards */
        }
        .card-clickable:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.3);
        }

        /* Player Hand Scroll Container */
        #player-cards {
            display: flex;
            overflow-x: auto;
            padding-bottom: 12px; /* Space for shadow/scroll bar */
            scroll-behavior: smooth;
            gap: 0; /* Managed by card margin-right */
        }
        /* Hide scrollbar for aesthetics */
        #player-cards::-webkit-scrollbar { height: 8px; }
        #player-cards::-webkit-scrollbar-thumb { background-color: #d1d5db; border-radius: 10px; }


        /* Card Colors */
        .R { background-color: #ef4444; } /* Red */
        .G { background-color: #10b981; } /* Green */
        .B { background-color: #3b82f6; } /* Blue */
        .Y { background-color: #f59e0b; } /* Yellow */
        /* Wild Card Look */
        .W { background: repeating-conic-gradient(#ef4444 0% 25%, #10b981 0% 50%, #3b82f6 0% 75%, #f59e0b 0% 100%); border-color: #333; }
        .W .card-color-initial, .W .card-value { text-shadow: 0 0 3px #000; }
        .gray { background-color: #4b5563; } /* Default/Loading Color */


        /* Mobile Adjustments */
        @media (max-width: 640px) {
            .card-base { width: 65px; height: 95px; min-width: 65px; }
            .card-value { font-size: 1.4rem; }
            .top-card { width: 100px; height: 140px; }
        }
    </style>
</head>
<body class="p-4 md:p-8 flex flex-col items-center justify-start">

    <div class="game-wrapper max-w-4xl mx-auto rounded-3xl p-6 md:p-10 mt-8">
        <h1 class="text-3xl font-extrabold text-gray-800 text-center mb-2">üÉè UNO Web Game</h1>

        <!-- Game Info & Controls -->
        <div class="flex flex-wrap justify-between items-center bg-gray-100 p-4 rounded-xl mb-6 border border-gray-200 shadow-sm">
            <div class="text-center p-2">
                <p class="text-sm text-gray-500">Your Cards</p>
                <span id="p1-count" class="text-3xl font-extrabold text-blue-600">7</span>
            </div>
            
            <div class="flex flex-col items-center p-2 space-y-2">
                <button id="new-game-btn" onclick="newGame()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-5 rounded-full shadow-lg transition duration-200">
                    New Game
                </button>
                <button id="draw-btn" onclick="drawCard()" disabled class="bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-2 px-6 rounded-full shadow-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                    Draw Card
                </button>
            </div>

            <div class="text-center p-2">
                <p class="text-sm text-gray-500">Opponent Cards</p>
                <span id="p2-count" class="text-3xl font-extrabold text-red-600">7</span>
            </div>
        </div>

        <!-- Message Area -->
        <div id="message" class="text-center p-4 rounded-xl font-bold mb-6 bg-blue-100 text-blue-800 border-2 border-blue-300">
            Click 'New Game' to start!
        </div>

        <!-- Strategy Output Area (New Gemini Feature) -->
        <div id="strategy-output" class="text-center p-4 rounded-xl font-medium mb-6 bg-indigo-50 text-indigo-700 border border-indigo-200">
            Strategy Coach ready.
        </div>
        
        <!-- Game Over Banner -->
        <div id="game-over-banner" class="hidden text-center p-6 rounded-xl bg-gradient-to-r from-green-500 to-green-700 text-white shadow-xl mb-6">
            <h2 id="winner-text" class="text-3xl font-bold">Winner!</h2>
            <p>Game Over.</p>
        </div>
        
        <!-- Center Area (Top Card & Draw Pile Count) -->
        <div class="flex flex-col items-center justify-center mb-8">
            <h3 class="text-lg font-bold text-gray-700 mb-3">Discard Pile</h3>
            <div id="top-card" class="card-base top-card R">R0</div>
            <p class="mt-4 text-sm font-medium text-gray-600">Draw Pile: <span id="draw-count" class="font-bold text-gray-900">26</span> cards</p>
        </div>

        <!-- Color Picker Modal (Hidden by Default) -->
        <div id="color-picker-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 z-50 flex items-center justify-center transition-opacity duration-300" style="display:none;">
            <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-lg w-full transform scale-100">
                <h3 class="text-2xl font-black mb-6 text-center text-gray-800">Choose a New Color</h3>
                <div class="grid grid-cols-2 gap-4">
                    <button class="R text-white py-4 rounded-xl font-extrabold shadow-lg hover:ring-4 ring-red-300 transition duration-150" onclick="selectWildColor('R')">RED</button>
                    <button class="G text-white py-4 rounded-xl font-extrabold shadow-lg hover:ring-4 ring-green-300 transition duration-150" onclick="selectWildColor('G')">GREEN</button>
                    <button class="B text-white py-4 rounded-xl font-extrabold shadow-lg hover:ring-4 ring-blue-300 transition duration-150" onclick="selectWildColor('B')">BLUE</button>
                    <button class="Y text-white py-4 rounded-xl font-extrabold shadow-lg hover:ring-4 ring-yellow-300 transition duration-150" onclick="selectWildColor('Y')">YELLOW</button>
                </div>
            </div>
        </div>

        <!-- Player Hand (Horizontal Scroll) -->
        <div class="player-hand border-t-2 border-gray-200 pt-6 mt-6">
            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Your Hand (Scroll Right ‚Üí)</h3>
            <div id="player-cards" class="cards-container">
                <!-- Cards will be rendered here -->
            </div>
        </div>
        
        <!-- Strategy Button Added -->
        <div class="flex justify-center mt-6 gap-4">
             <button id="strategy-btn" onclick="getStrategyAdvice()" disabled class="px-6 py-3 bg-fuchsia-600 hover:bg-fuchsia-700 text-white font-bold rounded-full shadow-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                ‚ú® Get Strategy Advice
            </button>
            <button id="skip-btn" onclick="skipDrawnTurn()" disabled class="px-6 py-3 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded-full shadow-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                Skip Turn
            </button>
        </div>
    </div>

    <script>
        // --- GEMINI API INTEGRATION ---
        const GEMINI_API_KEY = "";
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
        const MAX_RETRIES = 3;

        async function getStrategyAdvice() {
            if (!gameActive || !isPlayerTurn || pendingWildCard || gameOver) return;

            const handString = play1.join(', ');
            const topCardString = topCard;

            const systemPrompt = `You are an expert UNO strategy coach. Analyze the user's current hand and the top card. Provide a concise, single-paragraph piece of advice (max 50 words). Only suggest cards the user has and mention why they are good plays. If the user cannot play any card, tell them to draw.`;

            const userQuery = `Current Top Card: ${topCardString}. My Hand: ${handString}. What is the best strategy for my next move?`;
            
            document.getElementById('strategy-btn').disabled = true;
            document.getElementById('strategy-output').innerHTML = '<span class="text-indigo-600 font-bold">üß† Analyzing hand... Please wait.</span>';


            let responseText = "Could not connect to the strategy coach. Try again later.";
            
            for (let i = 0; i < MAX_RETRIES; i++) {
                const delay = Math.pow(2, i) * 1000;
                if (i > 0) await new Promise(resolve => setTimeout(resolve, delay));

                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                    };

                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`API returned status ${response.status}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        responseText = candidate.content.parts[0].text;
                        break; 
                    } else {
                        throw new Error("Invalid response structure from API.");
                    }

                } catch (error) {
                    if (i === MAX_RETRIES - 1) {
                        responseText = `Strategy Coach failed. Please check the console for details.`;
                    }
                }
            }

            document.getElementById('strategy-output').innerHTML = responseText;
            document.getElementById('strategy-btn').disabled = false;
        }

        // --- GAME STATE & CORE LOGIC (Fully integrated JavaScript) ---
        let play1 = [];
        let play2 = [];
        let drawPile = [];
        let topCard = '';
        let message = '';
        let isPlayerTurn = true;
        let gameActive = false;
        let pendingWildCard = null; 
        let lastPlayedCard = ''; 
        let gameOver = false; 
        let canPlayAfterDraw = false; // NEW: Controls ability to play/skip after drawing

        // Full 84-Card Deck (76 numbered + 8 Draw Two + 8 Wilds)
        const CARDS = [
            // --- NUMBERED CARDS (76 total) ---
            'R0', 'G0', 'B0', 'Y0',
            'R1', 'R1', 'R2', 'R2', 'R3', 'R3', 'R4', 'R4', 'R5', 'R5', 'R6', 'R6', 'R7', 'R7', 'R8', 'R8', 'R9', 'R9',
            'G1', 'G1', 'G2', 'G2', 'G3', 'G3', 'G4', 'G4', 'G5', 'G5', 'G6', 'G6', 'G7', 'G7', 'G8', 'G8', 'G9', 'G9',
            'B1', 'B1', 'B2', 'B2', 'B3', 'B3', 'B4', 'B4', 'B5', 'B5', 'B6', 'B6', 'B7', 'B7', 'B8', 'B8', 'B9', 'B9',
            'Y1', 'Y1', 'Y2', 'Y2', 'Y3', 'Y3', 'Y4', 'Y4', 'Y5', 'Y5', 'Y6', 'Y6', 'Y7', 'Y7', 'Y8', 'Y8', 'Y9', 'Y9',
            
            // --- ACTION CARDS (8 total) ---
            'R-D2', 'R-D2', 'G-D2', 'G-D2', 'B-D2', 'B-D2', 'Y-D2', 'Y-D2', 

            // --- WILD CARDS (8 total) ---
            'W-W', 'W-W', 'W-W', 'W-W',         
            'W-D4', 'W-D4', 'W-D4', 'W-D4'      
        ];

        // --- GAME UTILITIES ---

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function getCardColor(card) {
            if (!card) return 'W';
            // Returns the chosen color (R, G, B, Y) for Wilds (e.g., from W-R-W)
            if (card.startsWith('W-') && card.length > 2) {
                return card[2]; 
            }
            // Returns the card's base color (R, G, B, Y, or W)
            return card[0] || 'W';
        }
        
        function getCardInitial(card) {
            // Returns the initial for display (R, G, B, Y, or W)
            return card.startsWith('W-') ? 'W' : card[0];
        }

        function getCardValue(card) {
            if (!card) return 'Start';

            // 1. Wild cards with chosen color (W-R-W or W-R-D4)
            if (card.startsWith('W-') && card.length > 4) {
                 // Value is the part after the second hyphen (index 4)
                 return card.substring(4); // W-R-W -> W, W-R-D4 -> D4
            }
            // 2. Colored action cards (R-D2)
            if (card.includes('-')) {
                // Value is the part after the hyphen (index 2)
                return card.substring(2); // R-D2 -> D2
            }
            // 3. Number cards (R5)
            return card.substring(1); // R5 -> 5
        }

        function isWildCard(card) {
            return card.startsWith('W');
        }

        function isValidPlay(card, currentTopCard) {
            if (!currentTopCard) return true;
            if (isWildCard(card)) return true; // Wild cards can ALWAYS be played

            // Use helper functions for reliable extraction
            const playingColor = getCardColor(card); // e.g., 'R'
            const playingValue = getCardValue(card); // e.g., 'D2' or '5'
            
            const topColor = getCardColor(currentTopCard); // e.g., 'R' OR 'B' (if Wild set to Blue)
            const topValue = getCardValue(currentTopCard); // e.g., 'D2' or '5'

            // Match color OR match value/action
            return playingColor === topColor || playingValue === topValue;
        }


        // --- GAME LOGIC ---

        function newGame() {
            let initialDeck = [...CARDS];
            shuffle(initialDeck);

            play1 = [];
            play2 = [];
            drawPile = initialDeck;
            topCard = '';
            message = 'Shuffling and dealing...';
            isPlayerTurn = true;
            gameActive = true;
            pendingWildCard = null;
            lastPlayedCard = '';
            gameOver = false; // Reset game over state
            canPlayAfterDraw = false; // Reset

            // Deal 7 cards
            for (let i = 0; i < 7; i++) {
                if (drawPile.length > 0) play1.push(drawPile.pop());
                if (drawPile.length > 0) play2.push(drawPile.pop());
            }

            // Flip initial top card (must not be a draw card)
            do {
                topCard = drawPile.pop();
                if (topCard.includes('-D')) { 
                    drawPile.unshift(topCard); 
                    shuffle(drawPile);
                    topCard = ''; 
                }
            } while (!topCard);
            
            message = `Game started! Top card is ${getCardInitial(topCard)}${getCardValue(topCard)}. Your turn.`;
            renderGame();
        }

        function checkWin() {
            if (play1.length === 0) {
                message = 'Player 1 Wins! Congratulations!';
                gameActive = false;
                gameOver = true; // Set game over state
                return true;
            }
            if (play2.length === 0) {
                message = 'Player 2 Wins! Better luck next time.';
                gameActive = false;
                gameOver = true; // Set game over state
                return true;
            }
            return false;
        }

        // --- PLAYER ACTIONS ---

        function playCard(card) {
            if (!gameActive || !isPlayerTurn) return;
            if (pendingWildCard) return; 

            if (!isValidPlay(card, topCard)) {
                message = `Invalid move! ${getCardInitial(card)}${getCardValue(card)} does not match the top card.`;
                renderGame();
                return;
            }

            play1.splice(play1.indexOf(card), 1);
            
            // If it's a Wild card, prompt for color selection
            if (isWildCard(card)) {
                pendingWildCard = card;
                document.getElementById('color-picker-modal').style.display = 'flex';
                message = `You played a ${getCardValue(card)}. Choose a new color!`;
                canPlayAfterDraw = false; // Playing a card resets the draw-skip window
                renderGame();
                return; 
            }

            // For non-wild cards, update and apply effects immediately
            topCard = card;
            lastPlayedCard = card;
            canPlayAfterDraw = false; // Playing a card resets the draw-skip window
            
            // Action cards dictate if the turn is skipped, otherwise it passes to P2
            const mustPlayAgain = handleActionCardEffect(card, 'P1');
            
            if (checkWin()) {
                renderGame();
                return;
            }

            // End P1 turn, start AI turn
            if (!mustPlayAgain) { 
                isPlayerTurn = false;
                message = `You played ${getCardInitial(card)}${getCardValue(card)}. Player 2's turn...`;
                renderGame();
                setTimeout(handleAITurn, 1000);
            } else {
                 isPlayerTurn = true; 
                 message = `You played ${getCardInitial(card)}${getCardValue(card)}. Your turn again!`;
                 renderGame();
            }
        }

        function drawCard() {
            if (!gameActive || !isPlayerTurn || canPlayAfterDraw) return; // Cannot draw twice

            if (drawPile.length === 0) {
                message = 'Draw pile is empty! Skipping your turn.';
                isPlayerTurn = false;
                renderGame();
                setTimeout(handleAITurn, 1000);
                return;
            }

            const newCard = drawPile.pop();
            play1.push(newCard);
            message = `You drew a card (${getCardInitial(newCard)}${getCardValue(newCard)}). You can play it or skip your turn.`;
            
            // Turn remains TRUE, but we set flag allowing player to skip/play
            canPlayAfterDraw = true; 
            renderGame();
        }

        function skipDrawnTurn() {
            if (!gameActive || !isPlayerTurn || !canPlayAfterDraw) return;

            canPlayAfterDraw = false;
            isPlayerTurn = false;
            message = "Player 1 skipped turn after drawing. Player 2's turn...";
            renderGame();
            setTimeout(handleAITurn, 1000);
        }

        // --- WILD CARD LOGIC (P1) ---

        function selectWildColor(color) {
            const wildCard = pendingWildCard;
            const wildType = getCardValue(wildCard); 

            // Sets topCard to the specific Wild Color card (e.g., W-R-W or W-R-D4)
            topCard = `W-${color}-${wildType}`;
            
            // Apply wild effect (draw 4 or simple wild)
            const mustPlayAgain = handleActionCardEffect(wildCard, 'P1', color);
            
            document.getElementById('color-picker-modal').style.display = 'none';
            pendingWildCard = null;
            canPlayAfterDraw = false; // Playing a wild card resets the draw-skip window

            if (checkWin()) {
                renderGame();
                return;
            }

            // End P1 turn, start AI turn
            if (!mustPlayAgain) { 
                isPlayerTurn = false;
                message = `Wild played. Color changed to ${color}. Player 2's turn...`;
                renderGame();
                setTimeout(handleAITurn, 1000);
            } else {
                isPlayerTurn = true; 
                message = `Wild played. Color changed to ${color}. Your turn again!`;
                renderGame();
            }
        }

        // --- ACTION HANDLERS ---

        /**
         * Applies the effect of an action card (Draw 2/4).
         * @returns {boolean} True if the current player gets to play again (turn is skipped).
         */
        function handleActionCardEffect(card, player, chosenColor = null) {
            const cardValue = getCardValue(card); 
            let opponentHand = player === 'P1' ? play2 : play1;
            let opponentName = player === 'P1' ? 'Player 2' : 'Player 1';
            
            let turnStolen = false;

            // Draw Two (Colored) or Wild Draw Four
            if (cardValue === 'D2' || cardValue === 'D4') { 
                const drawCount = cardValue === 'D2' ? 2 : 4;
                for (let i = 0; i < drawCount; i++) {
                    if (drawPile.length > 0) opponentHand.push(drawPile.pop());
                }
                message = `${player} played ${getCardInitial(card)}${cardValue}. ${opponentName} draws ${drawCount} and is skipped!`;
                turnStolen = true; 
            } 
            
            return turnStolen;
        }

        // --- AI LOGIC (P2) ---

        function handleAITurn() {
            if (!gameActive || isPlayerTurn) return;
            
            // AI cannot skip turn after drawing, it must end its turn normally
            canPlayAfterDraw = false; 

            const playableCards = play2.filter(card => isValidPlay(card, topCard));
            let cardToPlay = null;

            if (playableCards.length > 0) {
                // AI Strategy: Prioritize Draw/Wild cards > Highest number
                const wildDrawFour = playableCards.find(c => getCardValue(c) === 'D4');
                const drawTwo = playableCards.find(c => getCardValue(c) === 'D2');
                const simpleWild = playableCards.find(c => getCardValue(c) === 'W');
                const numberCards = playableCards.filter(c => !isWildCard(c) && !c.includes('-'));

                if (wildDrawFour) {
                    cardToPlay = wildDrawFour;
                } else if (drawTwo) {
                    cardToPlay = drawTwo;
                } else if (simpleWild) {
                    cardToPlay = simpleWild;
                } else if (numberCards.length > 0) {
                    numberCards.sort((a, b) => parseInt(getCardValue(a)) - parseInt(getCardValue(b)));
                    cardToPlay = numberCards.pop();
                } else {
                    cardToPlay = playableCards[0]; 
                }
            }

            if (cardToPlay) {
                play2.splice(play2.indexOf(cardToPlay), 1);
                lastPlayedCard = cardToPlay;
                
                message = `Player 2 played ${getCardInitial(cardToPlay)}${getCardValue(cardToPlay)}.`;
                let mustPlayAgain = false;

                if (isWildCard(cardToPlay)) {
                    // AI chooses the color it has the most of 
                    const colorCounts = play2.reduce((acc, card) => {
                        const color = getCardInitial(card);
                        if (color !== 'W') acc[color] = (acc[color] || 0) + 1;
                        return acc;
                    }, {});
                    const colors = ['R', 'G', 'B', 'Y'];
                    let bestColor = 'R'; 
                    let maxCount = -1;

                    // Find color with max count, defaulting to R if no colored cards left
                    for (const color of colors) {
                        const count = colorCounts[color] || 0;
                        if (count > maxCount) {
                            maxCount = count;
                            bestColor = color;
                        }
                    }
                    
                    // Update topCard before applying effect
                    topCard = `W-${bestColor}-${getCardValue(cardToPlay)}`;
                    mustPlayAgain = handleActionCardEffect(cardToPlay, 'P2', bestColor);

                    message += ` Color changed to ${bestColor}.`;

                } else {
                    topCard = cardToPlay; // Update topCard for colored cards
                    mustPlayAgain = handleActionCardEffect(cardToPlay, 'P2');
                }
                
                if (checkWin()) {
                    renderGame();
                    return;
                }
                
                // --- FIX FOR MULTI-PLAY/TURN SWITCH ---
                if (mustPlayAgain) { 
                    isPlayerTurn = false; // P2's turn again (as P1 is the opponent)
                    message += " Player 2 plays again!";
                    renderGame();
                    setTimeout(handleAITurn, 1500); 
                } else { 
                    isPlayerTurn = true; // Switch back to P1
                    message += " Your turn!";
                    renderGame();
                }

            } else {
                // 3. AI must draw
                if (drawPile.length > 0) {
                    const newCard = drawPile.pop();
                    play2.push(newCard);
                    message = `Player 2 drew a card. Your turn!`;
                } else {
                    message = 'Draw pile empty. Player 2 skipped. Your turn!';
                }
                isPlayerTurn = true;
                renderGame();
            }
        }


        // --- UI RENDERING ---

        function renderGame() {
            const cardsContainer = document.getElementById('player-cards');
            const topCardElement = document.getElementById('top-card');

            // Update Info Counts
            document.getElementById('p1-count').textContent = play1.length;
            document.getElementById('p2-count').textContent = play2.length;
            document.getElementById('draw-count').textContent = drawPile.length;
            document.getElementById('message').textContent = message;

            // Update Top Card Display
            if (topCard) {
                const displayColor = getCardColor(topCard);
                const displayValue = getCardValue(topCard);
                const displayInitial = getCardInitial(topCard);

                topCardElement.innerHTML = `<span class="card-color-initial">${displayInitial}</span><span class="card-value">${displayValue}</span>`;
                topCardElement.className = `card-base top-card ${displayColor}`;
            }

            // Render Player 1 Hand (Horizontal Scroll)
            cardsContainer.innerHTML = '';
            play1.sort(); 
            play1.forEach(card => {
                const cardColor = getCardColor(card);
                const cardInitial = getCardInitial(card);
                const cardValue = getCardValue(card);
                
                // Card is playable if: game active, P1 turn, no pending wild, AND 
                // (it's a valid match OR player just drew and is allowed to play the drawn card)
                const isPlayable = gameActive && isPlayerTurn && !pendingWildCard && 
                                   (isValidPlay(card, topCard) || canPlayAfterDraw);


                const cardDiv = document.createElement('div');
                cardDiv.className = `card-base ${isPlayable ? 'card-clickable' : 'opacity-60 cursor-default'} ${cardColor}`;
                cardDiv.innerHTML = `<span class="card-color-initial">${cardInitial}</span><span class="card-value">${cardValue}</span>`;
                
                if (isPlayable) {
                    cardDiv.onclick = () => playCard(card);
                }
                cardsContainer.appendChild(cardDiv);
            });

            // Control Button State
            const drawBtn = document.getElementById('draw-btn');
            const skipBtn = document.getElementById('skip-btn');

            // Draw button is disabled if already drawn this turn, or not P1's turn
            drawBtn.disabled = !gameActive || !isPlayerTurn || !!pendingWildCard || canPlayAfterDraw;
            
            // Skip button is ONLY enabled if the player drew and hasn't played/skipped yet
            skipBtn.disabled = !canPlayAfterDraw;


            document.getElementById('new-game-btn').textContent = gameActive ? 'Restart Game' : 'New Game';
            document.getElementById('strategy-btn').disabled = !gameActive || !isPlayerTurn || !!pendingWildCard;
            
            // Game Over Banner
            const gameOverBanner = document.getElementById('game-over-banner');
            const winnerText = document.getElementById('winnerText');
            if (gameOver) {
                 gameOverBanner.classList.remove('hidden');
                 winnerText.textContent = message.includes("You won") ? 'You Win!' : 'You Lose!';
            } else {
                 gameOverBanner.classList.add('hidden');
            }
        }

        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', renderGame);
    </script>
</body>
</html>
37233d2c7
